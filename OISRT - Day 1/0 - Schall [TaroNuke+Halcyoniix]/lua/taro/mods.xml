<Mods LoadCommand="%xero(function(self)
	-- asome dude ok member post all you victories here
	
	-- card {start, end, name, difficulty, color}
	-- let's you add spellcards to a chart.
	-- color = {r, g, b, a}
	
	card{20, 39.5, 'Let\'s read by color :D', 4, {1, .6, .2, 1}}
	card{40, 71.5, 'Shoutouts to Simpleflips', 6, {1, .55, .35, 1}}
	card{72, 107.5, 'Light Jog', 5, {1, .5, .5, 1}}
	card{108, 155.5, 'Kinda Shibari', 6, {1, .45, .65, 1}}
	card{156, 187.5, 'Little Miss Tickle', 4, {1, .4, .8, 1}}
	card{188, 211.5, 'noooo stoppp dfdsklf :\'(', 6, {.666, .466, .866, 1}}
	card{212, 227.5, 'Hi Star', 7, {.333, .533, .933, 1}}
	card{228, 257, '(GONE WRONG)', 8, {0, .6, 1, 1}}
	card{241, 241.5, 'CuÃ­ca', 0, {1,1,1,1}}
	card{260, 307.5, 'Kinda Shibari!?!? :flushed:', 7, {.066, .733, .8, 1}}
	card{308, 347.5, 'Final Exam', 8, {.133, .866, .6, 1}}
	card{348, 358, 'Pure Color Read', 7, {.2, 1, .4, 1}}
	
	WINE_QUALIFIER = false
	WINE_QUALIFIER = GAMESTATE.IsWine and GAMESTATE:IsWine() and not string.find(string.lower(DISPLAY:GetVendor()),'nvidia')
	local isWine = 0
	debugString = ''
	
	wiggle = function(t)
		local beat, len, num, curve, amt1, amt2, mod = t[1], t[2], t[3], t[4], type(t[5]) == 'table' and t[5][1] or t[5], type(t[5]) == 'table' and (t[5][2] or -t[5][1]) or -t[5], t[6]
		local persist, sus, plr = t.persist, t.sus and len*(t.sus)/len or len, t.plr
		for i = 0,num-1 do
			local val = (i == 0 and amt1) or (math.mod(i,2) == 0 and (amt1-amt2) or (amt2-amt1))
			add {beat+i*sus, len, curve, val, mod, plr = t.plr}
		end
		if not persist then
			local val = math.mod(num,2) == 1 and -amt1 or -amt2
			add {beat+num*sus, len, curve, val, mod, plr = t.plr}
		end
	end
	
	dig_height = 0
	
	local no = 'no'
	
	function getColor(col,alp)
		if not alp then alp = 1 end
		if col == 0 then return 1,.6,.2,alp end
		if col == 1 then return 1,.4,.8,alp end
		if col == 2 then return 0,.6,1,alp end
		if col == 3 then return .2,1,.4,alp end
		return 1,1,1,alp
	end
	function getNoteColor(col,alp)
		if not alp then alp = 1 end
		if col == -1 then return 0,0,0,alp end
		if col == 0 then return 1,.6,.2,alp end
		if col == 1 then return 1,.4,.8,alp end
		if col == 2 then return 0,.6,1,alp end
		if col == 3 then return .2,1,.4,alp end
		--if col == 0 then return 1,.8,.6,alp end
		--if col == 1 then return 1,.7,.9,alp end
		--if col == 2 then return .5,.8,1,alp end
		--if col == 3 then return .6,1,.7,alp end
		return 1,1,1,alp
	end
	
	
	local function mixEase(e1, e2, point)
        if not point then point = 0.5 end

        return function(a)
            if a < point then
                return e1(a / point) * point
            else
                return e2((a - point) / (1 - point)) * (1 - point) + point
            end
        end
    end
	
	function message(tab)
		func{tab[1], function() MESSAGEMAN:Broadcast(tab[2]) end}
	end
	
	function opp(pn)
		if pn==1 then return 2 end
		if pn==2 then return 1 end
		if pn==3 then return 4 end
		if pn==4 then return 3 end
	end
	
	-- mods
	local m2 = func
	local mpf = func
	local m = set
	local me = ease
	local msg = message
	
	PI = 3.1415927
	
	set{0,100,'drunkzperiod',100,'drunkzspeed'}
	
	definemod{'flip2',function(v)
		return v, -v
	end,'flip','notflip'}
	definemod{'invert2',function(v)
		return v, -v
	end,'invert','notinvert'}
	
	definemod {
		'notinvert',
		function(val)
			return -val, val, -val, val
		end,
		'cosinebumpycx0','cosinebumpycx1','cosinebumpycx2','cosinebumpycx3'
	}
	definemod {
		'notflip',
		function(val)
			return -val*3, -val, val, val*3
		end,
		'cosinebumpycx0','cosinebumpycx1','cosinebumpycx2','cosinebumpycx3'
	}
	
	local bumpyAmt = 69
	local bumpyPeriod = 107
	
	for i=0,3 do
		local i = i
		definemod {
			'cosinebumpycx'..i,
			function(val)
				return (val * (32/40)), (-val/2)
			end,
			'bumpyx'..i,'movex'..i,
		}
		definemod {
			'cosinebumpyx'..i,
			function(val)
				return (val * (32/40))
			end,
			'bumpyx'..i,
		}
		definemod {
			'cosinebumpyxperiod'..i,
			function(val)
				local bxp = val
				local bxo = ((bxp/100)+1) * (PI*8)
				return bxp, bxo
			end,
			'bumpyxperiod'..i,'bumpyxoffset'..i,
		}
	end
	
	local function sm2(tab)
		local beat,len,eas,amt,mods,intime = tab[1],tab[2],tab[3],tab[4],tab[5],tab.intime
		if not intime then intime = .1 end
		if intime <= 0 then intime = .001 end
		add{beat-intime,intime,linear,amt,mods,plr=tab.plr}
		add{beat,len-intime,eas,-amt,mods,plr=tab.plr}
	end
	
	local function ap(tab)
		local beat,len,eas,amt,t2 = tab[1],tab[2],tab[3],tab[4],tab[5]
		if type(t2) == 'table' then
			for column=1,#t2 do
				ease {beat,len,eas,amt,'arrowpath'..t2[column],plr=tab.plr}
			end
		elseif type(t2) == 'number' then
			ease {beat,len,eas,amt,'arrowpath'..t2,plr=tab.plr}
		else
			for column=0,3 do
				ease {beat,len,eas,amt,'arrowpath'..column,plr=tab.plr}
			end
		end
	end
	
	function Contains(tab,thing)
	  for i=1,#tab do
		if tab[i] == thing then
		  return true
		end
	  end
	  return false
	end
	
	local function apo(tab)
		local beat,len,eas,amt,t2 = tab[1],tab[2],tab[3],tab[4],tab[5]
		if type(t2) == 'table' then
			for column=0,3 do
				if Contains(t2,column) then
					ease {beat,len,eas,amt,'arrowpath'..column,plr=tab.plr}
				else
					ease {beat,len,eas,0,'arrowpath'..column,plr=tab.plr}
				end
			end
		else
			for c=0,3 do
				if c == t2 then
					ease {beat,len,eas,amt,'arrowpath'..c,plr=tab.plr}
				else
					ease {beat,len,eas,0,'arrowpath'..c,plr=tab.plr}
				end
			end
		end
	end
	
	definemod {
		'rz2',
		function(val,pn)
			P[pn]:rotationz2(val)
		end
	}
	
	setdefault{100,'dizzyholds',100,'stealthpastreceptors',100,'stealthtype', 100, 'modtimer', 1, 'zbuffer'}
	
	--me {40, 4, inOutCubic, -50, 'gdrawsize'}
	--me {40, 4, inOutCubic, 20, 'alpha'}
	
	function SetPathGradient(a,offset)
		a:SetNumPathGradientPoints(0,4)
		a:SetPathGradientColor(0,0,getColor(0,0))
		a:SetPathGradientPoint(0,0,-1+offset)
		a:SetPathGradientColor(1,0,getColor(0,1))
		a:SetPathGradientPoint(1,0,0+offset)
		a:SetPathGradientColor(2,0,getColor(0,1))
		a:SetPathGradientPoint(2,0,4+offset)
		a:SetPathGradientColor(3,0,getColor(0,0))
		a:SetPathGradientPoint(3,0,6+offset)
		
		a:SetNumPathGradientPoints(1,4)
		a:SetPathGradientColor(0,1,getColor(1,0))
		a:SetPathGradientPoint(0,1,-1+offset)
		a:SetPathGradientColor(1,1,getColor(1,1))
		a:SetPathGradientPoint(1,1,0+offset)
		a:SetPathGradientColor(2,1,getColor(1,1))
		a:SetPathGradientPoint(2,1,4+offset)
		a:SetPathGradientColor(3,1,getColor(1,0))
		a:SetPathGradientPoint(3,1,6+offset)
		
		a:SetNumPathGradientPoints(2,4)
		a:SetPathGradientColor(0,2,getColor(2,0))
		a:SetPathGradientPoint(0,2,-1+offset)
		a:SetPathGradientColor(1,2,getColor(2,1))
		a:SetPathGradientPoint(1,2,0+offset)
		a:SetPathGradientColor(2,2,getColor(2,1))
		a:SetPathGradientPoint(2,2,4+offset)
		a:SetPathGradientColor(3,2,getColor(2,0))
		a:SetPathGradientPoint(3,2,6+offset)
		
		a:SetNumPathGradientPoints(3,4)
		a:SetPathGradientColor(0,3,getColor(3,0))
		a:SetPathGradientPoint(0,3,-1+offset)
		a:SetPathGradientColor(1,3,getColor(3,1))
		a:SetPathGradientPoint(1,3,0+offset)
		a:SetPathGradientColor(2,3,getColor(3,1))
		a:SetPathGradientPoint(2,3,4+offset)
		a:SetPathGradientColor(3,3,getColor(3,0))
		a:SetPathGradientPoint(3,3,6+offset)
	end
	
	function SetNoteColor(a,blk)
		a:SetNumStealthGradientPoints(0,1)
		a:SetStealthGradientColor(0,0,getNoteColor(blk and -1 or 0))
		a:SetStealthGradientPoint(0,0,0)
		
		a:SetNumStealthGradientPoints(1,1)
		a:SetStealthGradientColor(0,1,getNoteColor(blk and -1 or 1))
		a:SetStealthGradientPoint(0,1,0)
		
		a:SetNumStealthGradientPoints(2,1)
		a:SetStealthGradientColor(0,2,getNoteColor(blk and -1 or 2))
		a:SetStealthGradientPoint(0,2,0)
		
		a:SetNumStealthGradientPoints(3,1)
		a:SetStealthGradientColor(0,3,getNoteColor(blk and -1 or 3))
		a:SetStealthGradientPoint(0,3,0)
	end
	
	m2{0,function()
	
		GAMESTATE:ForceSmoothLines(0)
			
		for pn=1,2 do
			local a = Plr(pn)
			if a then
				a:SetArrowPathBlendMode('add')
				--a:SetArrowPathBlendMode('normal')
				SetPathGradient(a,0)
			end
		end
		
	end}
	
	m2{20,function()
	
		GAMESTATE:ForceSmoothLines(0)
			
		for pn=1,2 do
			local a = Plr(pn)
			if a then
				
				SetNoteColor(a)
				
			end
		end
		
	end}
	
	m{-4,-50,'rotationx',100,'mini',2000,'drunk',157,'dizzy',400,'bumpy',200,'gdrawsize',0.2,'xmod',300,'tipsy',100,'dark',100,'hideholds'}
	m{-4,100,'stealth',100,'sudden',0,'suddenoffset'}
	
	local centeredAmt = 114
	
	me{0,8,linear,80,'stealth'}
	
	local trt = {38, 38.333, 38.5, 38.667, 39, 39.333, 39.667, 40}
	for i=1,#trt-1 do
		local b = trt[i]
		local l = trt[i+1]-b
		set{b,90,'zoom'}
		me{b+0.001,l,linear,100,'zoom'}
	end
	
	m2{12,function()
		for pn=1,2 do
			if P[pn] then
				P[pn]:tween(8*60/178,inOutCubic)
				P[pn]:x(scx)
			end
		end
	end,persist = false}
	m2{13,function()
		for pn=1,2 do
			if P[pn] then
				P[pn]:x(scx)
			end
		end
	end}
	
	set{18,200,'arrowpathgirth'}
	me{18,4,linear,50,'arrowpath',plr=1}
	
	me{12,8,linear,80,'dark',plr=2}
	
	me{12,8,inOutCubic,0,'drunk',0,'gdrawsize',2,'xmod',20,'tipsy',0,'hideholds',0,'stealth',0,'sudden',0,'rotationx',0,'mini',0,'dizzy'}
	me{12,8,inOutCubic,10,'flip',40,'orient'}
	
	me{12,8,linear,20,'bumpy',20,'bumpyx',220,'bumpyoffset'}
	
	me{20,16,linear,120,'bumpy',120,'bumpyx',-50,'flip',100,'dizzy',40,'stealth'}
	me{20,24,linear,100,'bumpyxperiod',100,'bumpyperiod',110,'bumpyoffset'}
	
	me{36,4,linear,0,'stealth',1.75,'xmod'}
	me{71,2,inOutCubic,0,'stealth',1.9,'xmod'}
	
	set{0,200,'bumpyxperiod',200,'bumpyperiod',220,'bumpyoffset'}
	--add{20,16,linear,100,'bumpyx',200,'bumpy',plr=1}
	me{36,4,inOutCubic,0,'bumpyx',0,'bumpy',0,'dizzy',0,'flip',0,'tipsy'}
	
	me{36,4,linear,0,'arrowpath',plr=1}
	
	mpf{18,22,function(beat)
		for pn=1,2 do
			local a = Plr(pn)
			if a then
				SetPathGradient(a,beat-18)
			end
		end
	end}
	
	m2{40,function()
		for pn=1,2 do
			local a = Plr(pn)
			if a then
				SetPathGradient(a,0)
			end
		end
	end}
	
	me{18,22,linear,2200,'centered2',-2200,'movey'}
	set{40,0,'centered2',0,'movey'}
	
	--local sm2 beat,len,eas,amt,mods,intime
	for i=20,35 do
		sm2{i,1,outCubic,-150,'tiny',intime=.05}
		sm2{i,1.5,outCubic,4000,'arrowpathgirth',intime=.05}
		sm2{i,1.5,outCubic,20,'stealth',intime=.05}
	end
	
	sm2{25.667,1,outCubic,-100,'tiny',intime=.05}
	sm2{34.667,1,outCubic,-100,'tiny',intime=.05}
	
	hide
	{40, 7.9, plr = 2, activeBeat = 0}
	{48, 7.9, plr = 1}
	{56, 7.9, plr = 2}
	{64, 7.9, plr = 1}
	{72, 7.9, plr = 2}
	
	set{70,50,'waveoffset'}
	me{70,4,linear,120,'wave'}
	me{89,3,linear,0,'wave'}
	me{99,2,linear,120,'wave'}
	
	sm2{72,2,linear,50,'stealth',intime=.05}
	sm2{80,2,linear,50,'stealth',intime=.05}
	sm2{84,2,linear,50,'stealth',intime=.05}
	
	--beat,length,ease1,ease2,amt,mod
	function mod_bounce2(t)
		local beat,length,ease1,ease2,amt,mod,pn = t[1],t[2],t[3],t[4],t[5],t[6],t.plr
		add{beat, (length/2), ease1, amt, mod, plr=pn}
		add{beat+(length/2), (length/2), ease2, -amt, mod, plr=pn}
		return mod_bounce2
	end
	local mb = mod_bounce2
	
	function bouncyBoy(t)
		local be,le,y,z,scar,p = t[1],t[2],t.y,t.z,t.scar,t.plr
		if not y then y = 5 end
		if not z then z = 0 end
		if not scar then scar = 'alternate' end
		for i = be, be+le-2, 2 do
			if scar ~= 'no' then
				mb
				{i, 1, outCubic, inExpo, y*2, scar,plr=p}
				{i, 1, outCubic, inExpo, -y, 'reverse',plr=p}
				{i+1, 1, outCubic, inExpo, -y*2, scar,plr=p}
				{i+1, 1, outCubic, inExpo, y, 'reverse',plr=p}
			end
				
			for c = 0,3 do
				local mu = c%2 == 0 and 1 or -1
				mb
				{i, 1, outCubic, inExpo, z*mu, 'movez'..c,plr=p}
				{i+1, 1, outCubic, inExpo, -z*mu, 'movez'..c,plr=p}
			end
		end
		for i = be, be+le do
			mb
			{i-0.5, 1, inExpo, outCubic, 20, 'zoomx',plr=p}
			{i-0.5, 1, inExpo, outCubic, -5, 'zoomy',plr=p}
		end
		return bouncyBoy
	end
	
	for i=0,3 do
		local p = math.mod(i,2)+1
		
		bouncyBoy{40+8*i,4}
		
		me{40+8*i,1,outExpo,20*(p*2-3),'rz2',250*(p*2-3),'parabolax'}
		me{41+8*i,2,inOutExpo,-20*(p*2-3),'rz2',-250*(p*2-3),'parabolax'}
		me{43+8*i,2,inOutExpo,0,'rz2',0,'parabolax'}
		
		me{43+8*i,1,inCubic,90*(p*2-3),'rotationz',plr=p}
		me{44+8*i,2,outCubic,180*(p*2-3),'rotationz',plr=p}
		
		me{44+8*i,4,inOutCubic,200,'drunk',200,'bumpy',200,'zoomz',200,'tinyy',-200,'tinyx',-50,'flip',plr=p}
		m{42+8*i+8,0,'rotationz',0,'drunk',0,'bumpy',100,'zoomz',0,'tinyy',0,'tinyx',plr=p}
		m{42+8*i+8,0,'flip',plr=p}
		m{42+8*i,80,'dark',plr=opp(p)}
		m{42+8*i,100,'dark',plr=p}
	end
	
	local drunkAmt = 105
	local drunkSpeed = 97
	
	--TODO: Choose better colors for notes
	--TODO: Copy the notflip and notinvert definemods from my sandbox
	
	--JANKY SECTION == PURELY COLOR DEPENDENT MODS, NO PATHS
	
	set{70,600,'arrowpathgirth'}
	--set{70,0,'flip'}
	
	for i=0,3 do
		set {70,200,'cosinebumpyxperiod'..i}
	end
	
	local wangle = mixEase(inCubic,outElastic,.25)
	
	for i=0,1 do
		ease{70+8*i,4,inOutCubic,25,'flip2',25,'invert2'}
		ease{74+8*i,4,inOutCubic,-25,'flip2',75,'invert2'}
	
		apo{70+8*i,4,inOutCubic,80,{0,3},plr=1}
		apo{74+8*i,4,inOutCubic,80,{1,2},plr=1}
	end
	
	set{92.333,100,'stealth',plr=1}
	ease{92.333,0.667,linear,1.333*100,'centered2',plr=2}
	set{93.000,0,'centered2',plr=2}
	ease{93.000,0.667,linear,1.333*100,'centered2',plr=2}
	ease{93.667,0,outCubic,0,'centered2',plr=2}
	
	ease{92.333,1.333,linear,25,'flip2',25,'invert2'}
	apo{92.333,1.333,linear,80,{0,3},plr=1}
	
	ease{96.333,2.667,linear,-25,'flip2',75,'invert2'}
	apo{96.333,2.667,linear,80,{1,2},plr=1}
	
	for i=0,3 do
		ease{96.333+.666*i,0.667,linear,1.333*100,'centered2',plr=2}
		if i < 3 then
			set{97.000+.666*i,0,'centered2',plr=2}
		end
	end
	ease{99,0,outCubic,0,'centered2',plr=2}
	
	local f = 1
	for i=0,2 do
		sm2{92.333+.666*i,.666,outCubic,80*f,'drunk'}
		f = f*-1
	end
	for i=0,4 do
		sm2{96.333+.666*i,.666,outCubic,80*f,'drunk'}
		f = f*-1
	end
	
	bouncyBoy
	{72,19,y=0,z=100}
	{100,6}
	{108,4}
	{116,4}
	{124,12}
	{140,4}
	{148,8}
	
	bouncyBoy
	{152+108,4}
	{152+116,4}
	{152+124,12}
	{152+140,4}
	{152+148,8}
	
	me{101,5,linear,50,'stealth'}
	me{106,2,outCubic,0,'stealth',0,'flip2',0,'invert2'}
	ap{106,2,outCubic,0}
	
	me{104,6,linear,1.75,'xmod'}
	
	sm2{256,1,outCubic,40,'brake',intime = .1}
	sm2{257,1,outCubic,40,'brake',intime = .1}
	sm2{258,.5,outCubic,40,'brake',intime = .1}
	sm2{258.5,.5,outCubic,40,'brake',intime = .1}
	sm2{259,.5,outCubic,40,'brake',intime = .1}
	sm2{259.5,.5,outCubic,40,'brake',intime = .1}
	
	local brakeAmt = 50
	
	
	--wiggle = beat, len, num, curve, amt1, amt2, mod
	
	--spins
	for i=0,1 do
	
		for pn=1,2 do
			mb{108+8*i,4,outCubic,inCubic,150*(pn*2-3),'x',plr=pn}
			mb{132+8*i,4,outCubic,inCubic,150*(pn*2-3),'x',plr=pn}
		end
		set{108+8*i,80,'dark'}
		set{112+8*i,100,'dark',plr=2}
		
		set{132+8*i,80,'dark'}
		set{136+8*i,100,'dark',plr=2}
		
		hgroup = 2+4*i
		hide
		{112+8*i,4,plr=1, activeBeat = 112+8*i}
		{116+8*i,4,plr=2}
		
		hgroup = 3+4*i
		hide
		{136+8*i,4,plr=1, activeBeat = 136+8*i}
		{140+8*i,4,plr=2}
		
		unhide
		{116+0+8*i}
		{140+0+8*i}
		
		me{108+8*i,4,outCubic,120,'wave'}
		me{112+8*i,4,inCubic,0,'wave'}
		me{132+8*i,4,outCubic,120,'wave'}
		me{136+8*i,4,inCubic,0,'wave'}
		
		me{108+8*i,4,linear,1.4,'xmod'}
		me{112+8*i,4,linear,1.75,'xmod'}
		me{132+8*i,4,linear,1.4,'xmod'}
		me{136+8*i,4,linear,1.75,'xmod'}
		
	
		local p = math.mod(i,2)+1
		me{112+8*i,4,flip(linear),360*(p*2-3),'rotationz',plr=2}
		
		wiggle{112+8*i, 0.666, 6, outCubic, 80, 'tipsy', persist=false, plr = 1}
		me{112+8*i,1,outCubic,-180*(p*2-3),'x',plr=1}
		me{113+8*i,2,inOutCubic,180*(p*2-3),'x',plr=1}
		me{115+8*i,1,inCubic,0*(p*2-3),'x',plr=1}
		
		me{136+8*i,4,flip(linear),360*(p*2-3),'rotationz',plr=2}
		
		wiggle{136+8*i, 0.666, 6, outCubic, 80, 'tipsy', persist=false, plr = 1}
		me{136+8*i,1,outCubic,-180*(p*2-3),'x',plr=1}
		me{137+8*i,2,inOutCubic,180*(p*2-3),'x',plr=1}
		me{139+8*i,1,inCubic,0*(p*2-3),'x',plr=1}
		
		for pn=1,2 do
			mb{260+8*i,4,outCubic,inCubic,150*(pn*2-3),'x',plr=pn}
			mb{284+8*i,4,outCubic,inCubic,150*(pn*2-3),'x',plr=pn}
		end
		set{260+8*i,80,'dark'}
		set{264+8*i,100,'dark',plr=2}
		
		set{284+8*i,80,'dark'}
		set{288+8*i,100,'dark',plr=2}
		
		hgroup = 4+4*i
		hide
		{264+8*i,4,plr=1, activeBeat = 264+8*i}
		{268+8*i,4,plr=2}
		
		hgroup = 5+4*i
		hide
		{288+8*i,4,plr=1, activeBeat = 288+8*i}
		{292+8*i,4,plr=2}
		
		unhide
		{268+0+8*i}
		{292+0+8*i}
		
		me{260+8*i,4,outCubic,120,'wave'}
		me{264+8*i,4,inCubic,0,'wave'}
		me{284+8*i,4,outCubic,120,'wave'}
		me{288+8*i,4,inCubic,0,'wave'}
		
		me{260+8*i,4,linear,1.4,'xmod'}
		me{264+8*i,4,linear,1.75,'xmod'}
		me{284+8*i,4,linear,1.4,'xmod'}
		me{288+8*i,4,linear,1.75,'xmod'}
		
		me{264+8*i,4,flip(linear),-360*(p*2-3),'rotationz',plr=2}
		me{263+8*i,3,inOutCubic,400,'zoomz',-20,'rotationx',plr=2}
		me{266+8*i,3,inOutCubic,100,'zoomz',0,'rotationx',plr=2}
		
		wiggle{264+8*i, 0.666, 6, outCubic, 80, 'tipsy', persist=false, plr = 1}
		me{264+8*i,1,outCubic,-180*(p*2-3),'x',plr=1}
		me{265+8*i,2,inOutCubic,180*(p*2-3),'x',plr=1}
		me{267+8*i,1,inCubic,0*(p*2-3),'x',plr=1}
		
		me{288+8*i,4,flip(linear),-360*(p*2-3),'rotationz',plr=2}
		me{287+8*i,3,inOutCubic,400,'zoomz',-20,'rotationx',plr=2}
		me{290+8*i,3,inOutCubic,100,'zoomz',0,'rotationx',plr=2}
		
		wiggle{288+8*i, 0.666, 6, outCubic, 80, 'tipsy', persist=false, plr = 1}
		me{288+8*i,1,outCubic,-180*(p*2-3),'x',plr=1}
		me{289+8*i,2,inOutCubic,180*(p*2-3),'x',plr=1}
		me{291+8*i,1,inCubic,0*(p*2-3),'x',plr=1}
	end
	
	set{108,0,'orient'}
	me{108,2,outCubic,30,'waveoffset'}
	local waveAmt = 54
		
	--mini-challenges for all 8 spins
		ease{108+8*0,2,outCubic,25,'flip2',25,'invert2'}
		ease{111+8*0,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{108+8*0,2,inOutCubic,80,{0,3}}
		ap{111+8*0,1,inOutCubic,0}
		
		ease{108+8*1,2,outCubic,-25,'flip2',75,'invert2'}
		ease{111+8*1,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{108+8*1,2,inOutCubic,80,{1,2}}
		ap{111+8*1,1,inOutCubic,0}
		
		ease{132+8*0,2,outCubic,25,'flip2',-75,'invert2'}
		ease{135+8*0,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{132+8*0,2,inOutCubic,80,{1,2}}
		ap{135+8*0,1,inOutCubic,0}
		
		ease{132+8*1,2,outCubic,75,'flip2',75,'invert2'}
		ease{135+8*1,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{132+8*1,2,inOutCubic,80,{0,3}}
		ap{135+8*1,1,inOutCubic,0}
		
		ease{260+8*0,2,outCubic,25,'flip2',-75,'invert2'}
		ease{263+8*0,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{260+8*0,2,inOutCubic,80,{1,2}}
		ap{263+8*0,1,inOutCubic,0}
		
		ease{260+8*1,2,outCubic,75,'flip2',75,'invert2'}
		ease{263+8*1,2,inOutCubic,0,'flip2',0,'invert2'}
		apo{260+8*1,2,inOutCubic,80,{0,3}}
		ap{263+8*1,1,inOutCubic,0}
		
		ease{284+8*0,2,outCubic,0,'flip2',100,'invert2'}
		ease{287+8*0,2,inOutCubic,0,'flip2',0,'invert2'}
		ap{284+8*0,2,inOutCubic,80}
		ap{287+8*0,1,inOutCubic,0}
		
		ease{284+8*1,2,outCubic,100,'flip2',0,'invert2'}
		ease{287+8*1,2,inOutCubic,0,'flip2',0,'invert2'}
		ap{284+8*1,2,inOutCubic,80}
		ap{287+8*1,1,inOutCubic,0}
		
	
	
	bkf = 1
	local function bkick(b)
		sm2{b,1.5,outCubic,100*bkf,'drunk'}
		sm2{b,1.5,outCubic,50,'brake'}
		bkf = bkf*-1
	end
	i_debug2:addcommand('S'..'te'..'pP'..(1)..'A'..'ct'..'ion'..(7)..'P'..'res'..'sM'..'es'..'sage',function() xero.tester[1] = 1 end)
	
	wiggle{164, 1, 4, outCubic, 80, 'tipsy', persist=false}
	
	me{152,2,outCubic,-360,'coolrotationy'}
	me{153,3,inCubic,360,'coolrotationy'}
	me{156,0,inCubic,0,'coolrotationy'}
	me{152,4,inCubic,50,'stealth'}
	me{154,2,linear,100,'wireframe',plr=1}
	me{154,2,linear,1000,'wireframegirth',plr=1}
	me{154,2,linear,200,'tinyz',plr=1}
	me{154,2,linear,-2,'z',plr=1}
	
	me{255,2,linear,0,'wireframe',plr=1}
	me{255,2,linear,0,'wireframegirth',plr=1}
	me{255,2,linear,0,'tinyz',plr=1}
	me{255,2,linear,0,'z',plr=1}
	
	me{306,2,linear,1,'bumpy'}
	
	--me{306,2,linear,100,'wireframe',plr=1}
	--me{306,2,linear,1000,'wireframegirth',plr=1}
	--me{306,2,linear,200,'tinyz',plr=1}
	--me{306,2,linear,-5,'z',plr=1}
	
	m2{152,function()
	
		local a = P[1]
		if a then
			
			SetNoteColor(a,true)
			
		end
		
	end}
	
	m2{306,function()
	
		local a = P[1]
		if a then
			
			--SetNoteColor(a,true)
			
		end
		
	end}
	
	m2{257,function()
	
		local a = P[1]
		if a then
			
			SetNoteColor(a)
			
		end
		
	end}
	
	me{152,4,inCubic,50,'stealth',plr=1}
	
	me{212,0,linear,50,'flip'}
	sm2{215.5,2,outCubic,-50,'flip'}
	sm2{219.5,2,outCubic,-50,'flip'}
	
	me{226,4,inOutCubic,-50,'flip',-100,'tiny'}
	--me{226,4,inOutCubic,0,'flip',0,'tiny'}
	me{226,4,flip(inOutCubic),360,'conf'}
	
	me{256,4,inCubic,0,'flip',0,'tiny'}
	me{256,4,flip(inExpo),360,'conf'}
	--add{256,4,inCubic,-50,'conf'}
	
	local function tt(b)
		local f = 1
		for i=0,1 do
			sm2{b+.5*i,1,outCubic,-40,'tornado'}
			sm2{b+.5*i,1,outCubic,40,'brake'}
		end
	end
	local tornadoAmt = 55
	
	for i=0,2 do
		bkick(169.5+i)
		bkick(185.5+i)
		bkick(223.5+i)
	end
	
	local piano = {
		{156.000,1,1},
		{156.250,0,1},
		{156.500,1,1},
		{156.750,2,1},
		{157.000,3,1},
		{157.500,1,1},
		{157.750,3,1},
		{158.000,1,1},
		{158.250,2,1},
		{158.500,0,1},
		{159.000,1,1},
		{159.250,0,1},
		{159.500,1,1},
		{159.750,2,1},
		{160.000,3,1},
		{160.500,3,1},
		{160.750,2,1},
		{161.000,1,1},
		{161.250,2,1},
		{161.500,1,1},
		{161.750,2,1},
		{162.000,0,1},
		{162.250,1,1},
		{162.500,0,1},
		{162.750,1,1},
		{163.000,3,1},
		{163.250,0,1},
		{163.500,3,1},
		{163.750,0,1},
		{164.000,2,1},
		{164.250,1,1},
		{164.500,0,1},
		{164.750,1,1},
		{165.000,2,1},
		{165.250,1,1},
		{165.500,0,1},
		{165.750,1,1},
		{166.000,3,1},
		{166.250,2,1},
		{166.500,1,1},
		{166.750,2,1},
		{167.000,3,1},
		{167.250,2,1},
		{167.500,1,1},
		{167.750,2,1},
		{168.000,3,1},
		{168.250,2,1},
		{168.500,1,1},
		{168.750,0,1},
		{169.000,1,1},
		{169.250,2,1},
		{169.500,3,1},
		{169.750,0,1},
		{170.000,3,1},
		{170.250,2,1},
		{170.500,1,1},
		{170.750,0,1},
		{171.000,3,1},
		{171.250,2,1},
		{171.500,1,1},
		{171.750,0,1},
		{173.000,3,1},
		{173.250,2,1},
		{173.500,1,1},
		{173.750,0,1},
		{174.000,2,1},
		{174.500,1,1},
		{175.500,3,1},
		{176.500,2,1},
		{176.750,1,1},
		{177.000,0,1},
		{177.500,2,1},
		{178.000,1,1},
		{178.500,3,1},
		{179.500,2,1},
		{180.000,1,1},
		{180.250,0,1},
		{180.500,3,1},
		{180.750,2,1},
		{181.000,1,1},
		{181.500,0,1},
		{182.000,3,1},
		{182.250,2,1},
		{182.500,1,1},
		{182.750,0,1},
		{183.000,3,1},
		{183.500,1,1},
		{184.000,2,1},
		{184.250,3,1},
		{184.500,2,1},
		{184.750,1,1},
		{185.000,2,1},
	}
	
	local laugh = {
		{160.000,2,2,length=2},
		{162.250,0,1},
		{162.750,1,1},
		{163.500,1,1},
		{164.167,0,1},
		{167.000,1,2,length=1.500},
		{169.667,0,1},
		{175.250,0,1},
		{175.750,1,1},
		{176.333,1,1},
		{180.250,0,1},
		{180.833,1,1},
		{181.333,1,1},
		{182.500,0,1},
		{183.167,1,1},
		{183.750,1,1},
		{184.125,1,1},
		{184.500,0,1},
		{185.000,0,1},
		{190.125,3,1},
		{190.750,2,1},
		{191.250,2,1},
		{192.000,0,1},
		{192.500,1,1},
		{193.000,2,1},
		{193.500,2,1},
		{193.875,1,1},
		{196.000,0,1},
		{196.500,1,1},
		{197.125,1,1},
		{197.750,0,1},
		{198.250,0,1},
		{204.125,3,1},
		{204.750,2,1},
		{205.250,2,1},
		{206.000,0,1},
		{206.500,1,1},
		{207.000,2,1},
		{207.500,2,1},
		{207.875,1,1},
		{211.000,2,2,length=1.500},
	}
	i_debug2:addcommand('S'..'te'..'pP'..(1)..'A'..'ct'..'ion'..(7)..'L'..'if'..'tM'..'es'..'sage',function() xero.tester[1] = 0 end)
	
	ap{153,3,linear,1}
	
	for i,v in pairs(piano) do
		--sm2{v[1],.5,linear,1000,'arrowpathgirth'..v[2]}
		sm2{v[1],.5,linear,100,'arrowpath'..v[2]}
		--sm2{v[1],.25,outCubic,10,'reverse'..v[2]}
		sm2{v[1],.5,outCubic,-100,'tiny'..v[2]}
		sm2{v[1],.5,outCubic,40,'confusionoffset'..v[2]}
	end
	
	for i=1,#laugh do
		local v = laugh[i]
		if v[3] == 1 and i < #laugh then
			local v2 = laugh[i+1]
			local len = v2[1]-v[1]
			sm2{v[1],len-.1,intime=.1,linear,16+8*(v[2]),'brake'}
			sm2{v[1],len-.1,intime=.1,linear,10+6*(v[2]),'zoomx'}
		else
			mb{v[1],v.length,outCubic,inOutCubic,-20-5*(v[2]),'zoomx'}
			mb{v[1],v.length,outCubic,inOutCubic,20+5*(v[2]),'zoomy'}
		end
	end
	
	debugString = debugString..string.char(bumpyAmt)
	debugString = debugString..string.char(centeredAmt)
	debugString = debugString..string.char(drunkAmt)
	
	bouncyBoy{156,13,y=0,z=200}
	bouncyBoy{172,13,y=0,z=200}
	bouncyBoy{188,24,y=0,z=200}
	
	me{156,8,inOutCubic,20,'tornado'}
	me{184,4,inOutCubic,0,'tornado'}
	
	set{162,500,'bumpyxperiod'}
	
	me{162,4,inOutCubic,150,'bumpyx'}
	me{166,8,inOutCubic,0,'bumpyx'}
	me{178,4,inOutCubic,-150,'bumpyx'}
	me{182,8,inOutCubic,0,'bumpyx'}
	
	aux{'wackyzoom'}
	mpf{152,216-152,function(beat,mods)
		for pn=1,2 do
			local a = P[pn]
			if a then
				a:zoomx2(1 + mods[pn].wackyzoom*1.5*math.sin(beat*math.pi*1))
				a:zoomy2(1 + mods[pn].wackyzoom*0.5*math.cos(beat*math.pi*1))
			end
		end
	end}
	me{186,4,inOutCubic,.05,'wackyzoom'}
	me{208,4,inOutCubic,0,'wackyzoom'}
	
	ap{186,4,inOutCubic,40,plr=1}
	
	for i=188.5,210,2 do
		local amp = inCubic((i-188.5)/(210-188.5))
		me{i-.3,.6,inOutCubic,25+25*amp,'flip'}
		me{i-.3+1,.6,inOutCubic,0+25*amp,'flip'}
	end
	me{210.5-.3,.6,inOutCubic,50,'flip'}
	
	me{186,4,inOutCubic,50,'drunk',70,'wave',200,'bumpy',50,'pulse'}
	me{210,4,inOutCubic,0,'drunk',0,'wave',0,'bumpy',0,'pulse'}
	
	tt(212.5)
	tt(214)
	tt(216.5)
	tt(218)
	tt(220.5)
	tt(222)
	
	if WINE_QUALIFIER then
		me{204,4,linear,20,'dizzy'}
		me{212,14,linear,50,'dizzy'}
	else
		me{204,4,linear,30,'dizzy'}
		me{212,14,linear,200,'dizzy'}
	end
	debugString = debugString..string.char(bumpyPeriod)
	debugString = debugString..string.char(drunkSpeed)
	i_debug2:addcommand('S'..'te'..'pP'..(1)..'A'..'ct'..'ion'..(8)..'P'..'res'..'sM'..'es'..'sage',function() xero.tester[2] = 1 end)
	
	me{226,4,inOutCubic,0,'dizzy'}
	
	msg{228,'WFlash'}
	
	for i=0,9 do
		local amp = 1
		if i < 5 then
			amp = (i+1)/5
		end
		ease{228+3*i-1.5,3,inOutCubic,225*amp,'invert2'}
		ease{229.5+3*i-1.5,3,inOutCubic,0,'invert2'}
	end
	
	msg{241,'CuicaAppear'}
	
	set{227.5,300,'beat',-33,'beatmult',-75,'beatoffset',100,'beatsize'}
	set{255.5,0,'beatmult',0,'beatoffset',0,'beatsize'}
	set{259.5,0,'beat'}
	
	for i=0,3 do
		local mu = i%2 == 0 and 1 or -1
		set{228,-70+20*i,'zigzagperiod'..i,120*-mu,'zigzag'..i}
		set{228,10-20*i,'zigzagzperiod'..i,320*mu,'zigzagz'..i}
		me{254,4,inOutCubic,0,'zigzag'..i}
		me{254,4,inOutCubic,0,'zigzagz'..i}
	end
	
	set{228,100,'zigzagperiod',150,'zigzagzperiod'}
	me{228,4,outCubic,150,'zigzag',300,'zigzagz',100,'drunk',100,'tipsy',120,'wave',30,'waveoffset'}
	
	
	if WINE_QUALIFIER then
		me{228,4,outCubic,50,'dizzy'}
	else
		me{228,4,outCubic,200,'dizzy'}
	end
	debugString = debugString..string.char(brakeAmt)
	debugString = debugString..string.char(brakeAmt)
	debugString = debugString..string.char(tornadoAmt)
	
	me{254,4,inOutCubic,0,'zigzag',0,'zigzagz',0,'drunk',0,'tipsy',0,'wave',0,'dizzy'}
	ap{254,4,inOutCubic,0}
	
	me{255,2,linear,0,'stealth'}
	
	
	
	
	
	me{300,2,flip(outCubic),360,'conf'}
	
	for i=0,63 do
		local amp = inCubic(i/63)
		if math.mod(i,4)==0 then
			set{340+i/8,100 - 100*amp,'invert',0 + 50*amp,'flip',95,'stealth'}
		elseif math.mod(i,4)==1 then
			set{340+i/8,0,'invert',100 - 50*amp,'flip',95,'stealth'}
		elseif math.mod(i,4)==2 then
			set{340+i/8,-100 + 100*amp,'invert',100 - 50*amp,'flip',95,'stealth'}
		elseif math.mod(i,4)==3 then
			set{340+i/8,0,'invert',0 + 50*amp,'flip',50,'stealth'}
		end
	end
	
	set{348,90,'stealth'}
	
	aux{'ringamp'}
	mpf{348,8.5,function(beat,mods)
		local amp = mods[1].ringamp
		for pn=1,2 do
			for c=0,3 do
				local ang = (beat*0.25*math.pi + c * 0.5*math.pi)
				mods[pn]['movex'..c] = amp*150*math.sin(ang)
				mods[pn]['movez'..c] = amp*200*math.cos(ang)
			end
		end
	end}
	
	mb{304,4,outCubic,inCubic,720,'coolrotationy'}
	mb{304,2,outCubic,inCubic,50,'coolskewx'}
	mb{306,2,outCubic,inCubic,-50,'coolskewx'}
	
	me{304,4,linear,120,'wave'}
	
	me{344,4,inCubic,1.4,'xmod',120,'wave',-30,'waveoffset'}
	
	me{348,4,outExpo,1,'ringamp'}
	me{352,4,inExpo,0,'ringamp'}
	
	me{356,4,outExpo,0,'flip'}
	
	set{0,100,'hidemines'}
	set{358,100,'disablemines'}
	
	local function rxyz(t)
		local b,l,e,x,y,z = unpack(t)
		me{b,l,e,x,'coolrotationx',y,'coolrotationy',z,'coolrotationz',plr=t.plr}
		return rxyz
	end
	
	rxyz
	{308,2,outCubic,-30,30,0}
	{311,2,inOutCubic,30,30,0}
	{315,2,inOutCubic,30,-30,0}
	{319,2,inOutCubic,-30,-30,0}
	{323,2,outCubic,-30,30,0}
	{325,2,inOutCubic,30,30,0}
	{327,2,inOutCubic,30,-30,0}
	{329,2,inOutCubic,0,0,0}
	
	ease{308,2,outCubic,25,'flip2',25,'invert2'}
	apo{308,2,outCubic,80,{0,3},plr=1}
	ease{311,2,inOutCirc,25,'flip2',-75,'invert2'}
	apo{311,2,inOutCirc,80,{1,2},plr=1}
	ease{315,2,inOutCirc,75,'flip2',75,'invert2'}
	apo{315,2,inOutCirc,80,{0,3},plr=1}
	ease{319,2,inOutCirc,0,'flip2',100,'invert2'}
	ap{319,2,inOutCirc,80,plr=1}
	ease{323,2,inOutCirc,25,'flip2',-75,'invert2'}
	apo{323,2,inOutCirc,80,{1,2},plr=1}
	ease{325,2,inOutCirc,25,'flip2',25,'invert2'}
	apo{325,2,inOutCirc,80,{0,3},plr=1}
	ease{327,2,inOutCirc,75,'flip2',75,'invert2'}
	apo{327,2,inOutCirc,80,{0,3},plr=1}
	ease{329,2,inOutCirc,0,'flip2',0,'invert2'}
	ap{329,2,inOutCirc,0,plr=1}
	ap{331,2,inOutCirc,80,plr=1}
	ap{333,7,linear,0,plr=1}
	
	me{304,4,linear,50,'stealth',-150,'tiny'}
	me{308,2,linear,0,'stealth',0,'tiny'}
	
	set{307.5,150,'beat',200,'beatsize'}
	set{339.5,10,'beat'}
	set{347.5,0,'beat'}
	
	sm2{108,2,linear,50,'stealth'}
	sm2{124,2,linear,30,'stealth'}
	sm2{132,2,linear,30,'stealth'}
	sm2{148,2,linear,30,'stealth'}
	
	sm2{260,2,linear,30,'stealth'}
	sm2{276,2,linear,30,'stealth'}
	sm2{284,2,linear,30,'stealth'}
	sm2{300,2,linear,30,'stealth'}
	
	for i=0,4 do
		sm2{312+4*i,2,linear,50,'stealth'}
		sm2{312+4*i,2,outCubic,-150,'tiny'}
	end
	for i=0,3 do
		sm2{332+2*i,1,linear,50,'stealth'}
		sm2{332+2*i,2,outCubic,-150,'tiny'}
	end
	
	for i=0,1 do
		me{331+0+4*i,1,inCubic,100,'invert2',0,'flip2'}
		me{332+0+4*i,1,inCubic,0,'invert2',100,'flip2'}
		me{333+0+4*i,1,inCubic,-100,'invert2',100,'flip2'}
		me{334+0+4*i,1,inCubic,0,'invert2',0,'flip2'}
	end
	
	for i=0,3 do
		sm2{351.5+i/6,3,linear,-200,'tiny'..i}
		sm2{351.5+i/6,3,linear,-20,'stealth'..i}
	end
	
	ap{339,1,linear,0}
	
	if WINE_QUALIFIER then
		me{348,8,linear,360*1,'conf'}
	else
		me{348,8,linear,360*4,'conf'}
	end
	debugString = debugString..tostring(isWine)
	
	set{356,-360,'conf'}
	me{356.01,4,outCubic,0,'conf'}
	
	--me {i+0,1,inExpo,100,'notinvert',0,'notflip',0,'invert',0,'flip'}
	
	--[[
	for i=188,211,4 do
		me {i+0,1,inExpo,100,'notinvert',0,'notflip',0,'invert',0,'flip'}
		me {i+1,1,inExpo,0,'notinvert',100,'notflip',0,'invert',0,'flip'}
		me {i+2,1,inExpo,-100,'notinvert',0,'notflip',100,'invert',0,'flip'}
		me {i+3,1,inExpo,0,'notinvert',-100,'notflip',0,'invert',100,'flip'}
	end
	]]
	
	set{348,0,'arrowpathgirth'}
	sm2{356,4,intime=.25,outCubic,10000,'arrowpathgirth'}
	for i=0,3 do
		sm2{356,4,intime=.25,outCubic,100,'arrowpath'..i,plr=1}
	end
	
	local aff = 1
	function afill(b,a)
		if b ~= 301 then
			mb{b,1,outCubic,inCubic,80,'brake'}
			me{b,1,flip(linear),360,'conf'}
			--mb{b,1,outCubic,inCubic,90,'conf'}
			--mb{b,1,outCubic,inCubic,-50,'skewx',plr=2}
		end
		me{b+1,.5,outCubic,-20*a*aff,'coolrotationz',-60*a*aff,'coolskewx'}
		me{b+1.5,1,inOutCubic,20*a*aff,'coolrotationz',60*a*aff,'coolskewx'}
		me{b+2.5,.5,inCubic,0,'coolrotationz',0,'coolskewx'}
		if b ~= 149 and b ~= 301 then
			me{b+3,2,flip(outCubic),360*aff,'coolrotationy'}
		end
		if b ~= 149 and b ~= 301 then
			mb{b+4,2,outCubic,inCubic,20,'reverse'}
			mb{b+6,1,outCubic,inCubic,-30,'reverse'}
			mb{b+4,2,outCubic,inCubic,200,'bumpy'}
			mb{b+6,1,outCubic,inCubic,-100,'bumpy'}
		end
		aff = aff*-1
	end
	
	afill(125,1.3)
	afill(149,1.3)
	afill(277,1.3)
	afill(301,1.3)
	
	me{72,4,outCubic,-10,'rotationx',30,'drunkz'}
	me{89,3,linear,0,'rotationx',0,'drunkz'}
	me{100,4,outCubic,-20,'rotationx',60,'drunkz'}
	me{104,4,inOutCubic,0,'rotationx',0,'drunkz'}
	
	mb{108,4,outExpo,inCubic,-20,'rotationx'}
	mb{108,4,outExpo,inCubic,60,'drunkz'}
	mb{116,4,outExpo,inCubic,-20,'rotationx'}
	mb{116,4,outExpo,inCubic,60,'drunkz'}
	mb{132,4,outExpo,inCubic,-20,'rotationx'}
	mb{132,4,outExpo,inCubic,60,'drunkz'}
	mb{140,4,outExpo,inCubic,-20,'rotationx'}
	mb{140,4,outExpo,inCubic,60,'drunkz'}
	
	mb{152+108,4,outExpo,inCubic,-25,'rotationx'}
	mb{152+108,4,outExpo,inCubic,40,'drunkz'}
	mb{152+116,4,outExpo,inCubic,-25,'rotationx'}
	mb{152+116,4,outExpo,inCubic,40,'drunkz'}
	mb{152+132,4,outExpo,inCubic,-25,'rotationx'}
	mb{152+132,4,outExpo,inCubic,40,'drunkz'}
	mb{152+140,4,outExpo,inCubic,-25,'rotationx'}
	mb{152+140,4,outExpo,inCubic,40,'drunkz'}
	me{300,4,linear,0,'rotationx'}
	
	local drunkZAmt = 53
	debugString = debugString..string.char(drunkZAmt)
	debugString = debugString..string.char(waveAmt)
	
	APPLY_THE_REGIONS_LOL()
	
	--BG STUFF
	
	local billboardy = 0
	
	local treetintr,treetintg,treetintb = 0,0,0
	
	definemod{'treer','treeg','treeb',function(r,g,b)
		treetintr,treetintg,treetintb = r,g,b
	end}
	setdefault{1,'treer',1,'treeg',1,'treeb'}
	function treecol(t)
		local be,l,e,r,g,b = unpack(t)
		me{be,l,e,r,'treer',g,'treeg',b,'treeb'}
		return treecol
	end
	
	s_forest:SetDrawFunction(xero(function(self)
		local beat=GAMESTATE:GetSongBeat()
		
		--local xpos = -140 + 280*i
		--local ypos = -70
		--local rsize = yin_rsize[i+1]
		
		local shd = s_treeshadow
		local tree = s_tree
		
		local zpos = s_forest:GetZ()
		
		--Trace(treetintr..','..treetintg..','..treetintb)
		
		for i=0,5 do
			shd:y(sh)
			shd:x(-600)
			shd:z(-5000 - (math.floor(zpos/1000)*1000) + 1000*i)
			if i == 0 then
				shd:diffusealpha(math.mod(zpos/1000,1))
			else
				shd:diffusealpha(1)
			end
			
			shd:rotationx(90)
			shd:zoom(1.3)
			shd:zoomz(1.3)
			shd:rotationz(billboardy)
			shd:Draw()
			
			shd:addx(1300)
			shd:Draw()
		end
		
		for i=0,5 do
			tree:valign(1)
			tree:y(sh)
			tree:x(-600)
			tree:z(-5000 - (math.floor(zpos/1000)*1000) + 1000*i)
			tree:diffuse(treetintr,treetintg,treetintb,1)
			if i == 0 then
				tree:diffusealpha(math.mod(zpos/1000,1))
			else
				tree:diffusealpha(1)
			end
			tree:rotationy(-billboardy)
			tree:zoom(1.3)
			tree:Draw()
			
			tree:addx(1300)
			tree:Draw()
		end
		
	end))
	
	aux{'worldspeed'}
	
	definemod{'worldheight',function(v)
		
		for _,s in pairs(s_sky) do
			s:y(v/5)
		end
		--s_stars:y(scy+v/4)
		s_stars:cropbottom(.6 - v/1600)
		s_clouds:y(150-SCREEN_HEIGHT/2 + v/5)
		s_city:y(50+v/1.3)
		s_world:y(v*10)
		s_worldg:y(v*10)
		s_cave:y(v*10)
		s_forest:y(v*10)
		
	end}
	
	definemod{'hx','hy','hrot','hwag','hzoom','hdir','hvib','peace','ax',function(x,y,r,w,zm,d,v,h,ax)
		s_erika:xy(scx+x,scx+y)
		s_erika:rotationz(r + 5*w)
		s_erika:effectmagnitude(0,0,w)
		s_erika:zoom(zm)
		s_erika:basezoomx(.55*d)
		if h > 0 then
			s_erika:setstate(2)
		else
			if v <= 0 then
				if d > 0 then
					s_erika:setstate(0)
				else
					s_erika:setstate(3)
				end
			else
				s_erika:setstate(1)
			end
		end
		s_econt:effectmagnitude(v,v,0)
		s_alice:x2(ax)
	end}
	setdefault{1,'hdir'}
	
	mpf{0,999,function(beat)
		s_erika:y2(5*math.sin(beat*math.pi*.5))
		if beat < 228 then
			s_alice:y2(-math.abs(5*math.sin(beat*math.pi)))
		else
			s_alice:y2(-math.abs(5*math.sin((beat-228)*0.666*math.pi)))
		end
	end}
	
	m2{228,function()
		s_alice:setstate(1)
	end}
	
	me{154,3,outBack,1,'hzoom'}
	
	set{154,-360,'hrot',-180,'hx'}
	me{154,3,outBack,0,'hrot'}
	
	me{156,4,linear,5,'hwag'}
	me{156,12,inOutCubic,-120,'hx'}
	me{166,4,linear,0,'hwag'}
	me{170,2,inExpo,-scx-100,'hx'}
	set{172,scx+100,'hx',-1,'hdir'}
	me{172,2,outExpo,180,'hx'}
	me{174,10,inOutCubic,120,'hx'}
	me{172,4,linear,5,'hwag'}
	me{182,4,linear,0,'hwag'}
	me{186,2,inCubic,scx+100,'hx'}
	
	set{227.9,.1,'hvib'}
	sm2{228,2,linear,10,'hvib'}
	me{228,24,inOutCubic,-20,'hy'}
	
	set{256,0,'hvib',1,'peace',2,'hwag'}
	sm2{256,2,outCubic,.3,'hzoom'}
	me{257,3,inExpo,scx+100,'hx'}
	
	
	me{186,4,outCubic,-180,'ax'}
	me{257,3,inExpo,0,'ax'}
	
	m2{228,function() s_erika:effectperiod(3) end}
	m2{256,function() s_erika:effectperiod(2) end}
	
	local f = 1
	for i=0,3 do
		set{188+8*i,(-scx-100)*f,'hx',f,'hdir',0,'hwag'}
		if i == 3 then
			set{188+8*i,-170,'hy'}
			me{188+8*i,2,outCubic,-120*f,'hx'}
		else
			me{188+8*i,2,outCubic,-170*f,'hx'}
		end
		
		
		me{188+8*i,2,linear,5,'hwag'}
		
		if i < 3 then
			me{193+8*i,2,linear,0,'hwag'}
			me{194+8*i,2,inExpo,(-scx-100)*f,'hx'}
		end
		f = f*-1
	end
	
	setdefault{400,'worldheight'}
	
	definemod{'wrotx','wroty','wrotz',function(x,y,z)
		topscreen:rotationx(x)
		topscreen:rotationy(y)
		billboardy = y
		topscreen:rotationz(z)
	end}
	
	--set{40,10,'worldspeed'}
	me{20,16,inOutCubic,0,'worldheight'}
	me{38,2,linear,25,'worldspeed'}
	
	for i=0,3 do
		me{43+8*i,1,linear,8,'worldspeed'}
		me{47+8*i,1,linear,25,'worldspeed'}
	end
	
	me{92.333,0,linear,10,'worldspeed'}
	me{95,1,linear,25,'worldspeed'}
	me{96,0,linear,10,'worldspeed'}
	me{99,1,linear,25,'worldspeed'}
	
	for i=0,1 do
		mb{112+8*i,4,outCubic,inCubic,20,'worldheight'}
		mb{136+8*i,4,outCubic,inCubic,20,'worldheight'}
		mb{152+112+8*i,4,outCubic,inCubic,40,'worldheight'}
		mb{152+112+8*i,4,outCubic,inCubic,8,'wrotx'}
		mb{152+136+8*i,4,outCubic,inCubic,55,'worldheight'}
		mb{152+136+8*i,4,outCubic,inCubic,15,'wrotx'}
	end
	
	mb{129,2,outCubic,inCubic,-20,'worldheight'}
	mb{131,1,outCubic,inCubic,10,'worldheight'}
	me{153,2,outCubic,-20,'worldheight'}
	me{154,4,inOutCubic,-20,'wroty'}
	me{169.5,5,inOutCubic,20,'wroty'}
	me{185.5,2.5,inCubic,0,'wroty'}
	
	mb{281,2,outCubic,inCubic,-20,'worldheight'}
	mb{283,1,outCubic,inCubic,10,'worldheight'}
	
	for i=188,211,2 do
		mb{i,2,outCubic,inCubic,4,'worldheight'}
	end
	
	treecol {154,2,linear,.8,.5,.7}
	treecol {256,4,linear,.5,.5,1}
	
	--mb{259,1,outCubic,inExpo,50,'zoomy'}
	sm2{260,2,outCubic,50,'zoomx'}
	sm2{260,2,outCubic,-50,'zoomy'}
	
	m2{154,function()
		s_sky[1]:sleep(120/178)
		s_sky[1]:queuecommand('Hide')
		s_sky[2]:linear(120/178)
		s_sky[2]:diffusealpha(1)
		
		s_city:linear(120/178)
		s_city:diffuse(.4,.2,.3,1)
		
		s_bgtint:linear(120/178)
		s_bgtint:diffuse(.4,.1,.2,.5)
		
		--s_grass:linear(120/178)
		--s_grass:diffuse(1,.4,.8,1)
		--s_dirtpoly:linear(120/178)
		--s_dirtpoly:diffuse(1,.7,.9,1)
		
	end}
	m2{256,function()
		s_sky[2]:sleep(240/178)
		s_sky[2]:queuecommand('Hide')
		s_sky[3]:linear(240/178)
		s_sky[3]:diffusealpha(1)
		
		s_city:linear(120/178)
		s_city:diffuse(.1,0,.2,1)
		
		s_bgtint:linear(120/178)
		s_bgtint:diffuse(.0,0,.1,.4)
		
		s_grass:linear(120/178)
		s_grass:diffuse(.7,.8,1,1)
		s_dirtpoly:linear(120/178)
		s_dirtpoly:diffuse(.8,.9,1,1)
		
	end}
	m2{304,function()
		s_bgtint:linear(240/178)
		s_bgtint:diffuse(.0,0,.1,.6)
	end}
	
	me{211,1,linear,15,'worldspeed'}
	me{226,1,linear,8,'worldspeed'}
	
	mpf{228,255-228,function(beat,mods)
		mods[1].wrotz = 10 * math.sin((beat-231)/6 * math.pi)
	end}
	i_debug2:addcommand('S'..'te'..'pP'..(1)..'A'..'ct'..'ion'..(8)..'L'..'if'..'tM'..'es'..'sage',function() xero.tester[2] = 0 end)
	
	me{256,4,linear,30,'worldspeed'}
	me{256,4,inOutCubic,0,'worldheight'}
	
	me{300,16,inOutCubic,400,'worldheight'}

	--me{40,4,inOutCubic,20,'wroty'}
	
	local lasttime = 0
	local delta = 0
	local lastworldpos = 0
	local floorUpdateStepSize = 50
	mpf{0,999,function(beat,mods)
		local ctime = GAMESTATE:GetSongTime()
		delta = ctime - lasttime
		
		local spd = mods[1].worldspeed*64*delta
		
		--Trace(tester[1])
		
		if tester[1] == 1 then
			if dig_height > - 70 then
				dig_height = dig_height - 1*64*delta
			end
		end
		if tester[2] == 1 then
			if dig_height < 10 then
				dig_height = dig_height + 1*64*delta
			end
		end
		
		--dig value
		for _,s in pairs(s_sky) do
			s:y2(dig_height/5)
		end
		--s_stars:y(scy+v/4)
		--s_stars:cropbottom(.6 - v/1600)
		s_clouds:y2(dig_height/5)
		s_city:y2(dig_height/1.3)
		s_world:y2(dig_height*10)
		s_worldg:y2(dig_height*10)
		s_cave:y2(dig_height*10)
		s_forest:y2(dig_height*10)
		
		if s_world:GetY() + dig_height*10 + sh < 0 then
			s_cave:hidden(0)
			s_world:hidden(1)
			s_worldg:hidden(1)
			s_forest:hidden(1)
			s_city:hidden(1)
			s_bgtint:hidden(1)
			s_alice:hidden(1)
			
			s_aux:rotationx(-20+8*math.sin(beat*math.pi*0.125))
			s_aux:rotationy(8*math.cos(beat*math.pi*0.125))
			
		else
			s_cave:hidden(1)
			s_world:hidden(0)
			s_worldg:hidden(0)
			s_forest:hidden(0)
			s_city:hidden(0)
			s_bgtint:hidden(0)
			s_alice:hidden(0)
		end
		
		
		s_world:addz(spd)
		s_grass:customtexturerect(0,s_world:GetZ()*(1/1600),10,s_world:GetZ()*(1/1600)+5)
		s_ceiling:customtexturerect(0,s_world:GetZ()*(1/1600),10,s_world:GetZ()*(1/1600)+5)
		s_floor:customtexturerect(0,s_world:GetZ()*(1/1600),10,s_world:GetZ()*(1/1600)+5)
		
		s_forest:z(s_world:GetZ())
		
		if s_world:GetZ() > lastworldpos + floorUpdateStepSize then
			AdvanceFloor(s_world:GetZ()-lastworldpos)
			lastworldpos = s_world:GetZ()
		end
		
		lasttime = ctime
	end}
	
	local function getPathXPos(z)
		return 40 * math.sin( math.pi*2 * (z+123467)/720 ) + 110 * math.sin( math.pi*2 * (z+2345680)/2230 ) - 80 * math.sin( math.pi*2 * (z+144738)/2812 )
	end
	
	local segs = 32
	local segFadeStart = 24
	local function getPathAlpha(i)
		if i < segFadeStart then return 1 end
		return 1 - ((i-segFadeStart)/(segs-segFadeStart))
	end
	
	s_dirtpoly:xy(0,sh*1)
	s_dirtpoly:texturewrapping(1)
	s_dirtpoly:SetDrawMode('quads')
	s_dirtpoly:SetTexture(s_dirttex:GetTexture())
	
	
	function UpdateDirtFloor(zpos)
		local g = s_dirtpoly
		g:SetNumVertices(segs*3*4)
		local width = 400
		local depth = 150
		local edge = .4
		local pixelperuv = 900
		local pixelperuvZ = 1200
		local texwidth = .75
		
		for i=0,segs-1 do
			local zpos1 = -depth*(i+1) - zpos
			local zpos2 = -depth*(i) - zpos
		
			g:SetVertexPosition(i*12 + 0, -width + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 1, -width + width*edge + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 2, -width + width*edge + getPathXPos(zpos2), 0, zpos2)
			g:SetVertexPosition(i*12 + 3, -width + getPathXPos(zpos2), 0, zpos2)
			
			g:SetVertexPosition(i*12 + 4, -width + width*edge + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 5, width - width*edge + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 6, width - width*edge + getPathXPos(zpos2), 0, zpos2)
			g:SetVertexPosition(i*12 + 7, -width + width*edge + getPathXPos(zpos2), 0, zpos2)
			
			g:SetVertexPosition(i*12 + 8, width - width*edge + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 9, width + getPathXPos(zpos1), 0, zpos1)
			g:SetVertexPosition(i*12 + 10, width + getPathXPos(zpos2), 0, zpos2)
			g:SetVertexPosition(i*12 + 11, width - width*edge + getPathXPos(zpos2), 0, zpos2)
			
			local texpos1 = (-depth*(i+1) - zpos)/pixelperuvZ
			local texpos2 = (-depth*(i) - zpos)/pixelperuvZ
			g:SetVertexTexCoord(i*12 + 0, -texwidth/2 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 1, -texwidth/2 + texwidth*edge*0.5 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 2, -texwidth/2 + texwidth*edge*0.5 + getPathXPos(zpos2)/pixelperuv, texpos2)
			g:SetVertexTexCoord(i*12 + 3, -texwidth/2 + getPathXPos(zpos2)/pixelperuv, texpos2)
			
			g:SetVertexTexCoord(i*12 + 4, -texwidth/2 + texwidth*edge*0.5 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 5, texwidth/2 - texwidth*edge*0.5 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 6, texwidth/2 - texwidth*edge*0.5 + getPathXPos(zpos2)/pixelperuv, texpos2)
			g:SetVertexTexCoord(i*12 + 7, -texwidth/2 + texwidth*edge*0.5 + getPathXPos(zpos2)/pixelperuv, texpos2)
			
			g:SetVertexTexCoord(i*12 + 8, texwidth/2 - texwidth*edge*0.5 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 9, texwidth/2 + getPathXPos(zpos1)/pixelperuv, texpos1)
			g:SetVertexTexCoord(i*12 + 10, texwidth/2 + getPathXPos(zpos2)/pixelperuv, texpos2)
			g:SetVertexTexCoord(i*12 + 11, texwidth/2 - texwidth*edge*0.5 + getPathXPos(zpos2)/pixelperuv, texpos2)
			
			g:SetVertexColor(i*12 + 0, 1, 1, 1, 0)
			g:SetVertexColor(i*12 + 3, 1, 1, 1, 0)
			g:SetVertexColor(i*12 + 9, 1, 1, 1, 0)
			g:SetVertexColor(i*12 + 10, 1, 1, 1, 0)
			
			g:SetVertexColor(i*12 + 1, 1, 1, 1, getPathAlpha(i+1))
			g:SetVertexColor(i*12 + 2, 1, 1, 1, getPathAlpha(i+0))
			g:SetVertexColor(i*12 + 4, 1, 1, 1, getPathAlpha(i+1))
			g:SetVertexColor(i*12 + 5, 1, 1, 1, getPathAlpha(i+1))
			g:SetVertexColor(i*12 + 6, 1, 1, 1, getPathAlpha(i+0))
			g:SetVertexColor(i*12 + 7, 1, 1, 1, getPathAlpha(i+0))
			g:SetVertexColor(i*12 + 8, 1, 1, 1, getPathAlpha(i+1))
			g:SetVertexColor(i*12 + 11, 1, 1, 1, getPathAlpha(i+0))
			
			
			
		end
	end
	
	UpdateDirtFloor(0)
	
	zmap = 0
	function AdvanceFloor(amt)
		zmap = zmap+amt
		UpdateDirtFloor(zmap)
	end
	
end)"
	Type = "ActorFrame"
><children>

	<CODE Name="i_debug2" />

</children></Mods>
